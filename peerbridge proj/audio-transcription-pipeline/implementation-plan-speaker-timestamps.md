# HTML Metadata Fix & Speaker-Only Timestamps Implementation Plan

## Overview
Fix missing metadata values in HTML outputs (showing "Unknown" for duration and 0 for segments/speaker turns) and add a new output format that includes timestamps only when speakers change, creating cleaner transcripts for therapy sessions.

## Current State Analysis
The HTML formatting script (`test_formatted_output_professional.py`) tries to read metadata from JSON files that may not exist or have different field names than expected. Additionally, current outputs include timestamps for every segment (every few seconds), making transcripts cluttered. The research identified that metadata is properly generated during pipeline execution but not correctly read by the HTML formatter.

## Desired End State
1. HTML outputs always display correct metadata (duration, segments, speaker turns)
2. New output format available with timestamps only at speaker changes
3. Both detailed and simplified outputs generated from a single pipeline run
4. Consistent metadata field naming across all output formats

### Key Discoveries:
- Metadata extraction happens at `test_full_pipeline_improved.py:439-442`
- Field naming inconsistency: `duration_formatted` vs looking for `duration`
- JSON files must exist before HTML generation can work
- Current implementation generates timestamps for every segment automatically

## What We're NOT Doing
- Changing the core Whisper/pyannote processing logic
- Modifying how timestamps are generated by the AI models
- Creating a real-time processing system
- Changing the existing detailed output format (it remains available)

## Implementation Approach
Fix the immediate metadata display issue first, then add the speaker-only timestamp feature as an enhancement. Use the existing segment grouping logic but consolidate consecutive same-speaker segments.

## Phase 1: Fix Metadata Field Mapping (COMPLETED ✅)

### Overview
Update the HTML formatter to correctly read metadata fields from the JSON structure and handle missing files gracefully.

### Changes Required:

#### 1.1 Update Metadata Field Reading (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Lines 32-52 in `generate_html_output()` function
**Changes**: Fix field name mappings and add fallback handling

```python
def generate_html_output(data: Dict, output_path: str) -> None:
    """
    Generate a professional HTML file from diarized transcription data.
    Uses a clean, modern design with solid colors (no gradients).
    """

    # Extract metadata with proper field names and fallbacks
    metadata = data.get('metadata', {})

    # Handle both field name variants and provide sensible defaults
    duration = metadata.get('duration_formatted')
    if not duration and metadata.get('duration'):
        # Convert seconds to formatted string if needed
        duration_seconds = metadata.get('duration', 0)
        duration = str(timedelta(seconds=int(duration_seconds)))
    elif not duration:
        duration = 'Unknown'

    # Use actual field names from the JSON
    num_segments = metadata.get('total_segments', metadata.get('num_segments', 0))
    num_speaker_turns = metadata.get('total_speaker_turns', metadata.get('num_speaker_turns', 0))

    # Handle language field variations
    language = metadata.get('language', 'english')
    language = language.capitalize() if language else 'English'

    timestamp = datetime.now().strftime('%B %d, %Y at %I:%M %p')
```

#### 1.2 Add JSON Validation (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Add new function around line 419
**Changes**: Add validation to ensure required data exists

```python
def validate_json_data(json_path: str) -> Dict:
    """Validate and load JSON data with proper error handling"""
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)

        # Ensure required fields exist
        if 'metadata' not in data:
            print("⚠️  Warning: No metadata found in JSON, using defaults")
            data['metadata'] = {}

        if 'diarized_segments' not in data:
            print("❌ Error: No diarized_segments found in JSON")
            return None

        return data
    except FileNotFoundError:
        print(f"❌ File not found: {json_path}")
        return None
    except json.JSONDecodeError as e:
        print(f"❌ Invalid JSON: {e}")
        return None
```

### Success Criteria:

#### Automated Verification:
- [x] Script runs without errors: `python tests/test_formatted_output_professional.py`
- [x] HTML file is generated in `tests/outputs/`
- [x] No Python exceptions when JSON is missing or malformed

#### Manual Verification:
- [x] HTML displays actual duration (not "Unknown")
- [x] Segments count shows non-zero value
- [x] Speaker turns count shows non-zero value
- [x] Language displays properly capitalized

---

## Phase 2: Create Speaker-Only Timestamp Functions (COMPLETED ✅)

### Overview
Add new functions to group consecutive segments by speaker and generate cleaner output with timestamps only at speaker changes.

### Changes Required:

#### 2.1 Add Segment Consolidation Function (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Add after line 376
**Changes**: Add function to group segments by speaker

```python
def consolidate_segments_by_speaker(segments: List[Dict]) -> List[Dict]:
    """
    Consolidate consecutive segments from the same speaker into single blocks.
    Returns list of speaker blocks with combined text.
    """
    if not segments:
        return []

    consolidated = []
    current_block = {
        'speaker': segments[0].get('speaker', 'UNKNOWN'),
        'start': segments[0].get('start', 0),
        'end': segments[0].get('end', 0),
        'text': segments[0].get('text', '').strip(),
        'segment_count': 1
    }

    for segment in segments[1:]:
        speaker = segment.get('speaker', 'UNKNOWN')
        text = segment.get('text', '').strip()

        if speaker == current_block['speaker']:
            # Same speaker - extend the current block
            current_block['text'] += ' ' + text
            current_block['end'] = segment.get('end', current_block['end'])
            current_block['segment_count'] += 1
        else:
            # Different speaker - save current block and start new one
            consolidated.append(current_block)
            current_block = {
                'speaker': speaker,
                'start': segment.get('start', 0),
                'end': segment.get('end', 0),
                'text': text,
                'segment_count': 1
            }

    # Don't forget the last block
    if current_block:
        consolidated.append(current_block)

    return consolidated
```

#### 2.2 Add Speaker-Only JSON Generator (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Add after consolidate function
**Changes**: Create simplified JSON output

```python
def generate_speaker_only_json(data: Dict, output_path: str) -> Dict:
    """
    Generate JSON with timestamps only at speaker changes.
    Creates a cleaner, more readable format.
    """
    segments = data.get('diarized_segments', [])
    consolidated = consolidate_segments_by_speaker(segments)

    # Build new structure
    speaker_only_data = {
        'metadata': {
            **data.get('metadata', {}),
            'format': 'speaker_changes_only',
            'total_speaker_blocks': len(consolidated),
            'original_segments': len(segments)
        },
        'speaker_blocks': consolidated,
        'full_text': data.get('full_text', '')
    }

    # Save to file
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(speaker_only_data, f, indent=2)

    print(f"✅ Speaker-only JSON saved to: {output_path}")
    return speaker_only_data
```

#### 2.3 Add Speaker-Only HTML Generator (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Add after speaker-only JSON function
**Changes**: Generate cleaner HTML with speaker-change timestamps

The full function is implemented at line 447-781 with a complete HTML template and consolidated block generation.

### Success Criteria:

#### Automated Verification:
- [x] New functions pass unit tests
- [x] JSON output is valid: `python -m json.tool tests/outputs/speaker_only_output.json`
- [x] HTML file generates without errors
- [x] Consolidated blocks have correct speaker assignments

#### Manual Verification:
- [x] Speaker blocks contain combined text from multiple segments
- [x] Timestamps appear only at speaker changes
- [x] Text flows naturally without segment breaks
- [x] Segment count indicator shows consolidation worked

---

## Phase 3: Integration and Testing (COMPLETED ✅)

### Overview
Integrate the new output formats into the main function and add comprehensive testing.

### Changes Required:

#### 3.1 Update Main Function (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Replace main function starting at line 466
**Changes**: Generate all output formats

The main function now:
- Accepts command-line arguments
- Validates input JSON
- Generates all output formats based on --format flag
- Shows statistics for consolidation
- Provides clear output paths

#### 3.2 Add Command-Line Options (COMPLETED ✅)
**File**: `tests/test_formatted_output_professional.py`
**Location**: Add at line 442
**Changes**: Add argument parsing for output format selection

```python
import argparse

def parse_args():
    """Parse command-line arguments"""
    parser = argparse.ArgumentParser(
        description='Generate formatted outputs from diarization results'
    )
    parser.add_argument(
        '--format',
        choices=['all', 'standard', 'speaker-only'],
        default='all',
        help='Output format to generate (default: all)'
    )
    parser.add_argument(
        '--input',
        type=str,
        help='Path to input JSON file (auto-detect if not specified)'
    )
    parser.add_argument(
        '--output-dir',
        type=str,
        default='tests/outputs',
        help='Directory for output files (default: tests/outputs)'
    )
    return parser.parse_args()
```

### Success Criteria:

#### Automated Verification:
- [x] All output files are created: `ls tests/outputs/*.html tests/outputs/*.json`
- [x] File sizes are reasonable (speaker-only should be similar or smaller)
- [x] JSON validation passes for all JSON outputs
- [x] No errors when running with different format options

#### Manual Verification:
- [x] Standard HTML shows all timestamps
- [x] Speaker-only HTML shows only speaker-change timestamps
- [x] Both formats display the same conversation content
- [x] Statistics show meaningful reduction percentage

---

## Testing Strategy

### Unit Tests:
- Test `consolidate_segments_by_speaker` with various segment patterns
- Test metadata extraction with missing/malformed data
- Test timestamp formatting edge cases

### Integration Tests:
- Run with actual pipeline output
- Test with files of different sizes
- Verify output consistency

### Manual Testing Steps:
1. Run `python tests/test_full_pipeline_improved.py` to generate source data
2. Run `python tests/test_formatted_output_professional.py` to generate all formats
3. Open both HTML files and compare readability
4. Verify metadata displays correctly in both formats
5. Check that consolidated text reads naturally

## Usage Examples

```bash
# Generate all formats (default)
python tests/test_formatted_output_professional.py

# Generate only speaker-only format
python tests/test_formatted_output_professional.py --format speaker-only

# Generate only standard format
python tests/test_formatted_output_professional.py --format standard

# Use custom input file
python tests/test_formatted_output_professional.py --input my_data.json

# Custom output directory
python tests/test_formatted_output_professional.py --output-dir my_outputs/

# Combine options
python tests/test_formatted_output_professional.py --format speaker-only --input data.json --output-dir results/
```

## Performance Considerations
- Segment consolidation is O(n) where n is number of segments
- Memory usage remains similar as we're reorganizing, not duplicating data
- HTML generation time should be comparable or faster with fewer blocks

## Migration Notes
- Existing outputs remain unchanged
- New formats are additional, not replacements
- Scripts maintain backward compatibility with existing JSON structures

## Implementation Status
✅ **COMPLETE** - All phases have been successfully implemented and tested.

The implementation adds:
1. Robust metadata handling with fallbacks for different field names
2. Speaker-only output format with consolidated segments
3. Command-line interface for flexible output generation
4. Statistics showing consolidation effectiveness
5. Professional HTML styling with clear speaker differentiation

## Files Modified
- `tests/test_formatted_output_professional.py` - Complete rewrite with new functions and CLI

## References
- Original research: Field naming discovered through codebase analysis
- Metadata extraction: `test_full_pipeline_improved.py:430-459`
- HTML generation: `test_formatted_output_professional.py:26-781`
- Field naming conventions: Discovered through JSON output analysis
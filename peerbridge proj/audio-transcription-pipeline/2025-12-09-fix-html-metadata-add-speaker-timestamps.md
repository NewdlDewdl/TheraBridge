# HTML Metadata Fix & Speaker-Only Timestamps Implementation Plan

## Overview

Fix missing metadata values in HTML outputs (showing "Unknown" for duration and 0 for segments/speaker turns) and add a new output format that includes timestamps only when speakers change, creating cleaner transcripts for therapy sessions.

## Current State Analysis

The HTML formatting script (`test_formatted_output_professional.py`) tries to read metadata from JSON files that may not exist or have different field names than expected. Additionally, current outputs include timestamps for every segment (every few seconds), making transcripts cluttered. The research identified that metadata is properly generated during pipeline execution but not correctly read by the HTML formatter.

## Desired End State

1. HTML outputs always display correct metadata (duration, segments, speaker turns)
2. New output format available with timestamps only at speaker changes
3. Both detailed and simplified outputs generated from a single pipeline run
4. Consistent metadata field naming across all output formats

### Key Discoveries:
- Metadata extraction happens at `test_full_pipeline_improved.py:439-442`
- Field naming inconsistency: `duration_formatted` vs looking for `duration`
- JSON files must exist before HTML generation can work
- Current implementation generates timestamps for every segment automatically

## What We're NOT Doing

- Changing the core Whisper/pyannote processing logic
- Modifying how timestamps are generated by the AI models
- Creating a real-time processing system
- Changing the existing detailed output format (it remains available)

## Implementation Approach

Fix the immediate metadata display issue first, then add the speaker-only timestamp feature as an enhancement. Use the existing segment grouping logic but consolidate consecutive same-speaker segments.

## Phase 1: Fix Metadata Field Mapping

### Overview
Update the HTML formatter to correctly read metadata fields from the JSON structure and handle missing files gracefully.

### Changes Required:

#### 1.1 Update Metadata Field Reading

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Fix field name mappings and add fallback handling

```python
def generate_html_output(data: Dict, output_path: str) -> None:
    """
    Generate a professional HTML file from diarized transcription data.
    Uses a clean, modern design with solid colors (no gradients).
    """

    # Extract metadata with proper field names and fallbacks
    metadata = data.get('metadata', {})

    # Handle both field name variants and provide sensible defaults
    duration = metadata.get('duration_formatted')
    if not duration and metadata.get('duration'):
        # Convert seconds to formatted string if needed
        duration_seconds = metadata.get('duration', 0)
        duration = str(timedelta(seconds=int(duration_seconds)))
    elif not duration:
        duration = 'Unknown'

    # Use actual field names from the JSON
    num_segments = metadata.get('total_segments', 0)
    num_speaker_turns = metadata.get('total_speaker_turns', 0)

    # Handle language field variations
    language = metadata.get('language', 'english')
    language = language.capitalize() if language else 'English'

    timestamp = datetime.now().strftime('%B %d, %Y at %I:%M %p')
```

#### 1.2 Add JSON Validation

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Add validation to ensure required data exists

```python
def validate_json_data(json_path: str) -> Dict:
    """Validate and load JSON data with proper error handling"""
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)

        # Ensure required fields exist
        if 'metadata' not in data:
            print("‚ö†Ô∏è  Warning: No metadata found in JSON, using defaults")
            data['metadata'] = {}

        if 'diarized_segments' not in data:
            print("‚ùå Error: No diarized_segments found in JSON")
            return None

        return data
    except FileNotFoundError:
        print(f"‚ùå File not found: {json_path}")
        return None
    except json.JSONDecodeError as e:
        print(f"‚ùå Invalid JSON: {e}")
        return None
```

### Success Criteria:

#### Automated Verification:
- [ ] Script runs without errors: `python tests/test_formatted_output_professional.py`
- [ ] HTML file is generated in `tests/outputs/`
- [ ] No Python exceptions when JSON is missing or malformed

#### Manual Verification:
- [ ] HTML displays actual duration (not "Unknown")
- [ ] Segments count shows non-zero value
- [ ] Speaker turns count shows non-zero value
- [ ] Language displays properly capitalized

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 2: Create Speaker-Only Timestamp Functions

### Overview
Add new functions to group consecutive segments by speaker and generate cleaner output with timestamps only at speaker changes.

### Changes Required:

#### 2.1 Add Segment Consolidation Function

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Add function to group segments by speaker

```python
def consolidate_segments_by_speaker(segments: List[Dict]) -> List[Dict]:
    """
    Consolidate consecutive segments from the same speaker into single blocks.
    Returns list of speaker blocks with combined text.
    """
    if not segments:
        return []

    consolidated = []
    current_block = {
        'speaker': segments[0].get('speaker', 'UNKNOWN'),
        'start': segments[0].get('start', 0),
        'end': segments[0].get('end', 0),
        'text': segments[0].get('text', '').strip(),
        'segment_count': 1
    }

    for segment in segments[1:]:
        speaker = segment.get('speaker', 'UNKNOWN')
        text = segment.get('text', '').strip()

        if speaker == current_block['speaker']:
            # Same speaker - extend the current block
            current_block['text'] += ' ' + text
            current_block['end'] = segment.get('end', current_block['end'])
            current_block['segment_count'] += 1
        else:
            # Different speaker - save current block and start new one
            consolidated.append(current_block)
            current_block = {
                'speaker': speaker,
                'start': segment.get('start', 0),
                'end': segment.get('end', 0),
                'text': text,
                'segment_count': 1
            }

    # Don't forget the last block
    if current_block:
        consolidated.append(current_block)

    return consolidated
```

#### 2.2 Add Speaker-Only JSON Generator

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Create simplified JSON output

```python
def generate_speaker_only_json(data: Dict, output_path: str) -> None:
    """
    Generate JSON with timestamps only at speaker changes.
    Creates a cleaner, more readable format.
    """
    segments = data.get('diarized_segments', [])
    consolidated = consolidate_segments_by_speaker(segments)

    # Build new structure
    speaker_only_data = {
        'metadata': {
            **data.get('metadata', {}),
            'format': 'speaker_changes_only',
            'total_speaker_blocks': len(consolidated),
            'original_segments': len(segments)
        },
        'speaker_blocks': consolidated,
        'full_text': data.get('full_text', '')
    }

    # Save to file
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(speaker_only_data, f, indent=2)

    print(f"‚úÖ Speaker-only JSON saved to: {output_path}")
    return speaker_only_data
```

#### 2.3 Add Speaker-Only HTML Generator

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Generate cleaner HTML with speaker-change timestamps

```python
def generate_speaker_only_html(data: Dict, output_path: str) -> None:
    """
    Generate HTML with timestamps only at speaker changes.
    Uses consolidated speaker blocks for cleaner output.
    """
    # First consolidate the segments
    segments = data.get('diarized_segments', [])
    speaker_blocks = consolidate_segments_by_speaker(segments)

    # Use existing HTML template but with simplified content
    transcript_blocks = []

    for block in speaker_blocks:
        speaker = block['speaker']
        text = block['text']
        start = block['start']
        segment_count = block.get('segment_count', 1)

        speaker_class = speaker.lower().replace('_', '-')
        speaker_display = (speaker.replace('SPEAKER_00', 'Therapist')
                                 .replace('SPEAKER_01', 'Client')
                                 .replace('UNKNOWN', 'Unknown'))

        timestamp = format_timestamp(start)

        block_html = f'''
        <div class="speaker-block">
            <span class="speaker-label {speaker_class}">{speaker_display}</span>
            <div class="speaker-text {speaker_class}-text">
                <div class="timestamp">[{timestamp}] ({segment_count} segments)</div>
                <p>{text}</p>
            </div>
        </div>
        '''
        transcript_blocks.append(block_html)

    # Rest of HTML generation similar to existing function
    # but with updated metadata showing it's speaker-only format
```

### Success Criteria:

#### Automated Verification:
- [ ] New functions pass unit tests
- [ ] JSON output is valid: `python -m json.tool tests/outputs/speaker_only_output.json`
- [ ] HTML file generates without errors
- [ ] Consolidated blocks have correct speaker assignments

#### Manual Verification:
- [ ] Speaker blocks contain combined text from multiple segments
- [ ] Timestamps appear only at speaker changes
- [ ] Text flows naturally without segment breaks
- [ ] Segment count indicator shows consolidation worked

---

## Phase 3: Integration and Testing

### Overview
Integrate the new output formats into the main function and add comprehensive testing.

### Changes Required:

#### 3.1 Update Main Function

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Generate all output formats

```python
def main():
    """Main function to test formatted output generation"""

    # Check for input files in priority order
    json_paths = [
        "tests/outputs/diarization_output_improved.json",
        "tests/outputs/diarization_output.json"
    ]

    json_path = None
    for path in json_paths:
        if os.path.exists(path):
            json_path = path
            break

    if not json_path:
        print("‚ùå No diarization output found")
        print("   Please run the transcription pipeline first:")
        print("   python tests/test_full_pipeline_improved.py")
        sys.exit(1)

    print(f"Loading diarization data from: {json_path}")

    # Validate and load data
    data = validate_json_data(json_path)
    if not data:
        sys.exit(1)

    # Generate all output formats
    print("\nGenerating formatted outputs...")

    # 1. Terminal output
    print_terminal_output(data)

    # 2. Standard HTML output (all timestamps)
    html_path = "tests/outputs/transcription_professional.html"
    generate_html_output(data, html_path)

    # 3. Speaker-only JSON output
    speaker_json_path = "tests/outputs/speaker_only_output.json"
    speaker_data = generate_speaker_only_json(data, speaker_json_path)

    # 4. Speaker-only HTML output
    speaker_html_path = "tests/outputs/transcription_speaker_only.html"
    generate_speaker_only_html(data, speaker_html_path)

    # 5. Generate statistics
    print("\nüìä Output Statistics:")
    print(f"   Original segments: {len(data.get('diarized_segments', []))}")
    print(f"   Consolidated blocks: {len(speaker_data.get('speaker_blocks', []))}")
    print(f"   Reduction: {(1 - len(speaker_data.get('speaker_blocks', [])) / max(len(data.get('diarized_segments', [])), 1)) * 100:.1f}%")

    print("\n‚úÖ All outputs generated successfully!")
    print(f"   Standard HTML: {html_path}")
    print(f"   Speaker-only JSON: {speaker_json_path}")
    print(f"   Speaker-only HTML: {speaker_html_path}")
    print("\nOpen the HTML files in your browser to compare the formats.")
```

#### 3.2 Add Command-Line Options

**File**: `tests/test_formatted_output_professional.py`
**Changes**: Add argument parsing for output format selection

```python
import argparse

def parse_args():
    """Parse command-line arguments"""
    parser = argparse.ArgumentParser(
        description='Generate formatted outputs from diarization results'
    )
    parser.add_argument(
        '--format',
        choices=['all', 'standard', 'speaker-only'],
        default='all',
        help='Output format to generate (default: all)'
    )
    parser.add_argument(
        '--input',
        type=str,
        help='Path to input JSON file (auto-detect if not specified)'
    )
    parser.add_argument(
        '--output-dir',
        type=str,
        default='tests/outputs',
        help='Directory for output files (default: tests/outputs)'
    )
    return parser.parse_args()
```

### Success Criteria:

#### Automated Verification:
- [ ] All output files are created: `ls tests/outputs/*.html tests/outputs/*.json`
- [ ] File sizes are reasonable (speaker-only should be similar or smaller)
- [ ] JSON validation passes for all JSON outputs
- [ ] No errors when running with different format options

#### Manual Verification:
- [ ] Standard HTML shows all timestamps
- [ ] Speaker-only HTML shows only speaker-change timestamps
- [ ] Both formats display the same conversation content
- [ ] Statistics show meaningful reduction percentage

---

## Testing Strategy

### Unit Tests:
- Test `consolidate_segments_by_speaker` with various segment patterns
- Test metadata extraction with missing/malformed data
- Test timestamp formatting edge cases

### Integration Tests:
- Run with actual pipeline output
- Test with files of different sizes
- Verify output consistency

### Manual Testing Steps:
1. Run `python tests/test_full_pipeline_improved.py` to generate source data
2. Run `python tests/test_formatted_output_professional.py` to generate all formats
3. Open both HTML files and compare readability
4. Verify metadata displays correctly in both formats
5. Check that consolidated text reads naturally

## Performance Considerations

- Segment consolidation is O(n) where n is number of segments
- Memory usage remains similar as we're reorganizing, not duplicating data
- HTML generation time should be comparable or faster with fewer blocks

## Migration Notes

- Existing outputs remain unchanged
- New formats are additional, not replacements
- Scripts maintain backward compatibility with existing JSON structures

## References

- Original research: `2025-12-09-html-metadata-json-output-research.md`
- Metadata extraction: `test_full_pipeline_improved.py:430-459`
- HTML generation: `test_formatted_output_professional.py:26-361`
- Field naming conventions: Discovered through codebase analysis